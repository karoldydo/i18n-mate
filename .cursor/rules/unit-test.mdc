---
description: Testing best practices with React Testing Library and Vitest
globs: **/*.test.tsx,**/*.test.ts
alwaysApply: false
---

# Testing with React Testing Library

## General

- Leverage the `vi` object for test doubles - Use `vi.fn()` for function mocks, `vi.spyOn()` to monitor existing functions, and `vi.stubGlobal()` for global mocks. Prefer spies over mocks when you only need to verify interactions without changing behavior.
- Master `vi.mock()` factory patterns - Place mock factory functions at the top level of your test file, return typed mock implementations, and use `mockImplementation()` or `mockReturnValue()` for dynamic control during tests. Remember the factory runs before imports are processed.
- Use inline snapshots for readable assertions - Replace complex equality checks with `expect(value).toMatchInlineSnapshot()` to capture expected output directly in your test file, making changes more visible in code reviews.
- Monitor coverage with purpose and only when asked - Configure coverage thresholds in `vitest.config.ts` to ensure critical code paths are tested, but focus on meaningful tests rather than arbitrary coverage percentages.
- Make watch mode part of your workflow - Run `vitest --watch` during development for instant feedback as you modify code, filtering tests with `-t` to focus on specific areas under development.
- Explore UI mode for complex test suites - Use `vitest --ui` to visually navigate large test suites, inspect test results, and debug failures more efficiently during development.
- Handle optional dependencies with smart mocking - Use conditional mocking to test code with optional dependencies by implementing `vi.mock()` with the factory pattern for modules that might not be available in all environments.
- Structure tests for maintainability - Group related tests with descriptive `describe` blocks, use explicit assertion messages, and follow the Arrange-Act-Assert pattern to make tests self-documenting.
- Leverage TypeScript type checking in tests - Enable strict typing in your tests to catch type errors early, use `expectTypeOf()` for type-level assertions, and ensure mocks preserve the original type signatures.

## Configuration

- Do NOT use `cleanup` - it happens automatically in modern Testing Library versions
- Do NOT use `any` - provide a type instead, if not possible use `as unknown as ...` or `as ...`
- Co-locate tests with their source files (Component.test.tsx next to Component.tsx)
- each constant variable that represents a `mock` should be named in camelCase (e.g. `mockProject`, `mockLocale`, `mockKey`, `mockTranslation`, `mockUser`, `mockSupabaseError`, `mockSupabaseResponse`, etc.) or use factory functions (e.g. `createMockProject()`, `createMockSupabaseError()`)
- Each constant variable that represents a `mock` should be typed by using existing types from the codebase
- All comments should be in inline comments (//) and written in lowercase.

## Querying Elements

- Use `screen` instead of destructuring queries from `render()` for better autocomplete and maintainability
- Use `screen.debug()` for debugging instead of destructuring `debug`
- Follow the query priority order from "Which query should I use?":
  1. `getByRole` (most preferred - matches accessibility tree)
  2. `getByLabelText` (for form fields)
  3. `getByPlaceholderText`
  4. `getByText`
  5. `getByDisplayValue`
  6. `getByAltText`
  7. `getByTitle`
  8. `getByTestId` (last resort)
- Query by accessible roles and names: `screen.getByRole('button', { name: /submit/i })`
- Query by actual text content, not test IDs, to ensure translations work correctly
- Do NOT use `container.querySelector()` - it bypasses accessibility and reduces confidence
- Do NOT use `getByTestId` unless there's no accessible alternative

## Query Variants

- Use `getBy*` for elements that should be present immediately
- Use `findBy*` for elements that appear asynchronously (instead of `waitFor` + `getBy*`)
- Use `queryBy*` ONLY for asserting element does NOT exist: `expect(screen.queryByRole('alert')).not.toBeInTheDocument()`
- Do NOT use `queryBy*` for positive assertions - use `getBy*` for better error messages

## Assertions

- Use `jest-dom` matchers for better error messages: `toBeDisabled()`, `toBeInTheDocument()`, `toHaveTextContent()`
- Do NOT use generic assertions like `expect(button.disabled).toBe(true)` - use `expect(button).toBeDisabled()`
- Make existence assertions explicit: `expect(screen.getByRole('alert')).toBeInTheDocument()`

## User Interactions

- Use `@testing-library/user-event` instead of `fireEvent` for more realistic user interactions
- `user-event` fires all the same events a real user would (e.g., `keyDown`, `keyPress`, `keyUp`)
- Do NOT use `fireEvent` unless `user-event` doesn't support the interaction yet

## Async Testing and waitFor

- Use `findBy*` queries for async elements instead of `waitFor(() => getBy*())`
- Put only ONE assertion per `waitFor` callback for faster failure feedback
- Do NOT pass empty callbacks to `waitFor` - wait for specific assertions
- Do NOT perform side-effects inside `waitFor` - put them outside
- Do NOT use snapshot assertions inside `waitFor` - take snapshots after `waitFor` completes

```typescript
// ❌ Wrong
await waitFor(() => {});
await waitFor(() => {
  fireEvent.click(button);
  expect(screen.getByRole('alert')).toBeInTheDocument();
});

// ✅ Correct
fireEvent.click(button);
await waitFor(() => expect(screen.getByRole('alert')).toBeInTheDocument());
```

## act() Usage

- Do NOT wrap `render()` or `fireEvent` in `act()` - they're already wrapped
- Only use `act()` when you need to manually trigger React updates outside Testing Library utilities
- If you see act warnings, investigate the root cause instead of wrapping things in `act()`

## Variable Naming

- Do NOT use `wrapper` as variable name for render return value
- Destructure what you need: `const { rerender } = render(<Example />)`
- Or use `view` if you need the whole object: `const view = render(<Example />)`

## Test Structure

- Use descriptive test names that explain user behavior or component functionality
- Follow Arrange-Act-Assert pattern
- Test user-visible behavior, not implementation details
- Avoid testing internal state or calling component methods directly

## Utilities

The `@/test/utils` folder contains reusable test utilities organized into several files:

### `test-data.ts` - Mock Data Fixtures

Provides consistent mock data for testing common entities:

- **`createMockProject()`** - Creates a mock project object with all required fields
- **`createMockProjectLocale()`** - Creates a mock project locale for testing
- **`createMockProjectWithCounts()`** - Creates a mock project with key and locale counts for list views
- **`createMockSupabaseError()`** - Creates structured Supabase error objects
- **`createMockSupabaseResponse()`** - Creates mock Supabase API responses
- **`createMockTelemetryEvent()`** - Creates a mock telemetry event for testing
- **`generateTestId()`** - Generates unique IDs for test data
- **`generateTestUuid()`** - Generates a valid UUID v4 for testing

### `test-helpers.ts` - Testing Helper Functions

Common utilities for setting up and running tests:

- **`createErrorBoundaryWrapper()`** - Creates a wrapper with ErrorBoundary and QueryClient for testing useSuspenseQuery hooks
- **`createMockSupabaseClient()`** - Creates a mock Supabase client with auth and database methods
- **`renderWithProviders()`** - Custom render function that wraps components with all necessary providers (QueryClient, etc.)
- **`wait()`** - Utility for waiting a specified number of milliseconds in async tests

### `test-wrapper.tsx` - Test Provider Wrapper

React component wrapper for testing:

- **`createTestWrapper()`** - Creates a reusable wrapper component with QueryClientProvider configured for testing (disables retries, etc.)

### `index.ts` - Central Exports

Re-exports all utilities from the above files for convenient importing:

```typescript
import { renderWithProviders, createMockProject, createMockSupabaseClient } from '@/test/utils';
```

Use these utilities to:

- Maintain consistent test data across tests
- Reduce boilerplate when setting up mocks
- Ensure proper provider setup for React Query and other context providers
- Create realistic Supabase client mocks for API testing

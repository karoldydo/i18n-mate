---
description: Supabase authentication integration for React 19 + Vite applications
globs: src/features/auth/**/*.ts,src/features/auth/**/*.tsx,src/shared/api/supabase*.ts,src/app/providers/SupabaseProvider.tsx
alwaysApply: false
---

# Supabase Auth Integration for React 19 + Vite

Best practices for implementing authentication in i18n-mate using Supabase Auth with React Context and TanStack Query.

## ⚠️ Important Implementation Notes

**All code samples in this guide are pseudo-code examples only.** Before implementing authentication:

1. **Analyze the existing project architecture** - Review current patterns in `src/features/*/`, `src/shared/`, and `src/app/`
2. **Ensure consistency** - Implementation must follow established patterns for:
   - Error handling (see existing `src/shared/types/types.ts`)
   - API client usage (see `src/shared/api/`)
   - Component structure (see existing features)
   - State management (TanStack Query patterns)
   - Form handling (react-hook-form + Zod patterns)
3. **Check existing implementations** - Look at how other features handle similar patterns (CRUD operations, mutations, queries)
4. **Follow naming conventions** - Use established naming patterns for hooks, components, and API functions
5. **Maintain feature boundaries** - Authentication should be a proper feature module in `src/features/auth/`

**Do not copy code samples verbatim** - adapt them to match the existing codebase architecture and patterns.

## Core Requirements

1. Use React Context (`AuthContext`) with provider (`AuthProvider`) for global authentication state
2. Implement custom hook `useAuth` exposing authentication data and methods
3. Use TanStack Query for user data caching and session management
4. Integrate with Supabase Auth session listener for automatic state updates
5. Implement proper email verification flow (session only after verification)
6. Use shared Supabase client from `src/shared/api/supabase.client.ts`

## Environment Variables

Store Supabase credentials in `.env` file:

```env
VITE_SUPABASE_URL=your_project_url
VITE_SUPABASE_ANON_KEY=your_anon_key
```

Update `src/env.d.ts` for TypeScript support:

```typescript
interface ImportMetaEnv {
  readonly VITE_SUPABASE_URL: string;
  readonly VITE_SUPABASE_ANON_KEY: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
```

## Implementation Structure

### 1. Supabase Client Setup

Create shared client in `src/shared/api/supabase.client.ts`:

```typescript
import { createClient } from '@supabase/supabase-js';
import type { Database } from '../types';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
  },
});

export type SupabaseClient = typeof supabase;
```

### 2. Authentication Context and Provider

Create `src/app/providers/SupabaseProvider.tsx`:

```typescript
import { createContext, useContext, useEffect, useState } from 'react';
import { supabase } from '@/shared/api/supabase.client';
import type { User } from '@supabase/supabase-js';

interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  signUp: (email: string, password: string) => Promise<void>;
  signIn: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
  resendVerification: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Get initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setUser(session?.user ?? null);
      setIsLoading(false);
    });

    // Listen for auth changes
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      setIsLoading(false);
    });

    return () => subscription.unsubscribe();
  }, []);

  const signUp = async (email: string, password: string) => {
    const { error } = await supabase.auth.signUp({
      email,
      password,
    });
    if (error) throw error;
  };

  const signIn = async (email: string, password: string) => {
    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });
    if (error) throw error;
  };

  const signOut = async () => {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
  };

  const resetPassword = async (email: string) => {
    const { error } = await supabase.auth.resetPasswordForEmail(email);
    if (error) throw error;
  };

  const resendVerification = async () => {
    if (!user?.email) throw new Error('No user email available');
    const { error } = await supabase.auth.resend({
      type: 'signup',
      email: user.email,
    });
    if (error) throw error;
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading,
        signUp,
        signIn,
        signOut,
        resetPassword,
        resendVerification,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

### 3. Authentication Hooks with TanStack Query

Create feature-specific hooks in `src/features/auth/hooks/`:

```typescript
// useAuthUser.ts - For user data with TanStack Query
import { useQuery } from '@tanstack/react-query';
import { useAuth } from '@/app/providers/SupabaseProvider';
import { supabase } from '@/shared/api/supabase.client';

export function useAuthUser() {
  const { user } = useAuth();

  return useQuery({
    queryKey: ['auth-user', user?.id],
    queryFn: async () => {
      if (!user?.id) return null;

      const { data, error } = await supabase.from('profiles').select('*').eq('id', user.id).single();

      if (error) throw error;
      return data;
    },
    enabled: !!user?.id,
  });
}

// useSignUp.ts
import { useMutation } from '@tanstack/react-query';
import { useAuth } from '@/app/providers/SupabaseProvider';

export function useSignUp() {
  const { signUp } = useAuth();

  return useMutation({
    mutationFn: ({ email, password }: { email: string; password: string }) => signUp(email, password),
  });
}

// useSignIn.ts
import { useMutation } from '@tanstack/react-query';
import { useAuth } from '@/app/providers/SupabaseProvider';

export function useSignIn() {
  const { signIn } = useAuth();

  return useMutation({
    mutationFn: ({ email, password }: { email: string; password: string }) => signIn(email, password),
  });
}
```

### 4. Route Protection with AuthGuard

Create `src/features/auth/components/AuthGuard.tsx`:

```typescript
import { useAuth } from '@/app/providers/SupabaseProvider';
import { Navigate, useLocation } from 'react-router-dom';

interface AuthGuardProps {
  children: React.ReactNode;
  requireVerified?: boolean;
}

export function AuthGuard({ children, requireVerified = true }: AuthGuardProps) {
  const { user, isLoading } = useAuth();
  const location = useLocation();

  if (isLoading) {
    return <div>Loading...</div>; // Replace with proper loading component
  }

  if (!user) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  if (requireVerified && !user.email_confirmed_at) {
    return <Navigate to="/verify-email" replace />;
  }

  return <>{children}</>;
}
```

### 5. Authentication Forms

Example login form in `src/features/auth/components/forms/LoginForm.tsx`:

```typescript
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useSignIn } from '../../hooks/useSignIn';
import { Button } from '@/ui/button';
import { Input } from '@/ui/input';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/ui/form';

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});

type LoginFormData = z.infer<typeof loginSchema>;

export function LoginForm() {
  const [showPassword, setShowPassword] = useState(false);
  const signIn = useSignIn();

  const form = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: '',
      password: '',
    },
  });

  const onSubmit = (data: LoginFormData) => {
    signIn.mutate(data, {
      onSuccess: () => {
        // Redirect handled by AuthGuard or useNavigate
      },
      onError: (error) => {
        form.setError('root', { message: error.message });
      },
    });
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input {...field} type="email" />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="password"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Password</FormLabel>
              <FormControl>
                <Input {...field} type={showPassword ? 'text' : 'password'} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit" disabled={signIn.isPending}>
          {signIn.isPending ? 'Signing in...' : 'Sign in'}
        </Button>
      </form>
    </Form>
  );
}
```

## Integration with Application

### 1. Add AuthProvider to App

Update `src/app/App.tsx`:

```typescript
import { AuthProvider } from './providers/SupabaseProvider';
// ... other imports

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        {/* Rest of your app */}
      </AuthProvider>
    </QueryClientProvider>
  );
}
```

### 2. Protect Routes

Update `src/app/routes.ts`:

```typescript
import { AuthGuard } from '@/features/auth/components/AuthGuard';

export const routes = [
  {
    path: '/',
    element: (
      <AuthGuard>
        <Dashboard />
      </AuthGuard>
    ),
  },
  {
    path: '/login',
    element: <LoginPage />,
  },
  {
    path: '/register',
    element: <RegisterPage />,
  },
  // ... other routes
];
```

## Error Handling

Use the existing error handling pattern from the application:

```typescript
import { useSignIn } from '../../hooks/useSignIn';
import { toast } from 'sonner';

const signIn = useSignIn();

signIn.mutate(data, {
  onSuccess: () => {
    toast.success('Successfully signed in!');
  },
  onError: (error) => {
    toast.error(error.message || 'Failed to sign in');
  },
});
```

## Security Best Practices

- Never expose Supabase keys in client-side code (already handled by VITE\_ prefix)
- Use HTTPS in production
- Implement proper password policies
- Use email verification before granting session access
- Handle token refresh automatically (configured in Supabase client)
- Validate all user input with Zod schemas
- Use proper error handling without exposing sensitive information

## Common Patterns

### Optimistic Updates for Auth Actions

```typescript
const signOut = useSignOut();

signOut.mutate(undefined, {
  onMutate: async () => {
    // Optimistically clear user state
    queryClient.setQueryData(['auth-user'], null);
  },
  onError: (error) => {
    // Revert optimistic update on error
    queryClient.invalidateQueries({ queryKey: ['auth-user'] });
  },
});
```

### Email Verification Check

```typescript
const { user } = useAuth();

if (user && !user.email_confirmed_at) {
  return <EmailVerificationRequired />;
}
```

### Session Persistence

Session persistence is automatically handled by Supabase client configuration. User state is maintained across page refreshes and browser sessions.
